ConnectionStorage абстракция над разными типами хранилищ данных.
С реляционными базами данных все просто.

Рассмотрим как работать с NoSQL архитектурой. 

**nosql и serverless архитектура**
Используя nosql нет смысла использовать middle layer. Веб апликация должна напрямую 
работать с nosql  базой данных.
Ведь если перекодировать json (nosql отдает json) в С# классы а потом назад в json - это съедает всю скорость 
и родную "распределенность".  Это то что называют Serverless архитектурой.

Это означает что абстракция в виде javascript интерфейсов над aws и azure должна быть на уровне клиента (react)

Поэтому классический middle layer, только для реляционных баз данных. 
Какие-то кусочки кода на C# в которых идет обращение к cosmos или dynamo могут существовать для нужд тестирования.

Это означает что в react приложение берет на себя следующие задачи характерные для middle layer:
1. Аутентификация и авторизация
2. Валидация данных
3. Лог и трейсинг

При этом особого дублирования не происходит, просто все эти задачи выполняются на клиенте. 

Аутентификация и авторизация на клиенте - это не значит что они не защищены. Но это своя специфика.

Аутентификация через react - задача получить токен доступа к базе данных. Используются сторонние сервисы/ свои сервисы с сторонними библиотеками для аутентификации.
Хорошо работает с родной аутентификацией для azure и aws (AWS Cognito, Azure AD B2C / MSAL.js). 

Авторизация через react - задача опредлить имеет ли пользователь доступ к определенной операции. 
Два способа:
 1) не напрямую, а через Serverless API (AWS Lambda, Azure Function) - "облачная функция" проверит userID и jwt и затем выполнит нужную операцию
 2) напрямую, но через настройку прямого доступа (IAM роли для DynamoDB, user-level access control с RBAC и resource tokens для CosmosDB)   
Второй способ не гибкий, покрывает только базовые операции.

Альтернатива serverless архитектуре  Backend-as-a-Service - сторонние сервисы (Firebase, AWS Amplify, Supabase over Postgres, Appwrite) 
предоставляют готовые решения ДБ+аутентификации+авторизация. Например предлогая row level security.

**О структуре данных в nosql**

ID из мира RDBMS это не тоже самое что partition key в NoSQL.

Если partition key создавать с каждой записью это приведёт к большому количеству partition'ов а значит перерасходу ресурсов, 
дорогим операциям (кеши и индексы), плохой масштабируемости ("на основе nosql начинаем строить RDBMS").Это неправильно.

ПРАВИЛЬНО: Partition key это атрибут данных который "выбирают" исходя из логики приложения "что нужно показать на экране". Например:
- Все записи одного пользователя — partitionKey = userId
- Все заказы одного клиента — partitionKey = clientId
- Все сообщения в одном чате — partitionKey = chatId

Значения Partition key в таком случае не "создаются" автоинкрементом, секвенсом или генерацией GUID, а какое-то поле записи
назначается partition key'ом (например userId).  

Важным вопросом на который надо ответить проектируя структуру данных является: а для каких операций по изменению данных нужна
атомарная транзакция?
В nosql транзакция "называется" batch-операцией и она может быть выполнена только в пределах одного
partition'а (userId = "IljaZ"). Т.е. если на клиенете есть редактирование данных разделенных на записи, а затем 
кнопка "сохранить" (или чекбоксами пометил и "удалить", или выделил селектом и "трансформировать/клонировать" ) то это все
должно быть в пределах одного и того же partition key (его конкетного значения).

**Случай "классификаторы"**
То что мы знаем в мире RDBMS как "классификаторы".
1) Все мелкие классификторы (10K-20K) помещают под partition называемый словарем 
{"dictionary": "remeltStatus" /*это partition*/, value: "completed"}. Тут сколько классификаторов столько
будет значений у dictionary. Но хорошим дизайном считается что те словари, что нужны для создания "уи" 
(заполнения комбобоксов и т.п.) заливают в один и тот же partition  и считывают за один раз: 
{"partitionKey": "dictionary" /*это один  partition key, для всех статусов */, "dictionaryType": "remeltStatus" 
/*это доп фильтр*/, "value":"completed"} - и затем раскидывают по уи "фильтрованием перебором" по доп фильтру).

Если все классификаторы в одном и том же partition key то сортировать каждый раз перед показом на клиенте.
Если каждому классификатору разный partition key то сортировать на клиенте стандартными средствами (sort key в DynamoDB, 
SQL запрос с ORDER BY в CosmosDB).

2) С большими классификаторами (например страны-города, почтовые индексы)  что вообще  чувствуется, как "новый сервис", "другая услуга"  
начинают много думать о разных partition'ах. Тут начинается и "натягивание совы на глобус" типа составных значений для partition 
key: "USA|NewYork" (так-то составные partition key невозможны, но склеивают строки чтобы получить "аналогичную функциональность").

**Pagination и infinite scroll***
Нельзя сделать OFFSET 20 LIMIT 10. Нельзя узнать число записей в таблице а значит и число страниц.
Вместо этого используется "пагинация по ключу продолжения" - LastEvaluatedKey (DynamoDB), continuationToken (CosmosDB)  - 
Запрашиваешь первую страницу, и получаешь "ключ", с которого продолжать следующую страницу.
Пропустить страницы нельзя. Но можно запрашивать c фильтром от определённого значения (естественно для времени) при 
этом ключ продложения поддерживается. На фильтер должна быть включена сортировка. В DynamoDB - один ключ соритировки (sortKey), 
в CosmosDB - индексирование можно включать по всем полям.

**Time-series database**
В каком-то смысле TSDB тоже nosql - оптимизированы под append-only модель, и "никаких join'ов".
InfluxDB, Prometheus - не требуют схемы. Но не все такие, TimescaleDB это расширение PostgreSQL. В TSDB нужна аналитика а значит
необходимы мехнизмы агрегирования, поэтому иногда TSDB делают поверх RDBMS (настраивают планировщик, table partitioning, 
материализованные агрегаты). Но TSDB созданные поверх RDBMS гораздо больше по размеру: "страницы фиксированного размера, хранят null 
значения", поэтому "безсхемные" TSDB предпочтительней - в "измерениях" бывает очень много нулей ("процесс то работает, то стоит").
Тем не менее в безсхемных TSDB нет partition key, а типы записей отличаются по "имени метрики" для Prometheus, "measurement" для 
InfluxDB. Безсхемные TSDB достигают высокой производительности агрегатов по времении за счет десятка разных решений ускоряющих 
доступ к данным, их размер.





 
